<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node-RED Split/Joinノード完全ガイド</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #8f0000;
            border-bottom: 3px solid #8f0000;
            padding-bottom: 10px;
        }
        h2 {
            color: #8f0000;
            margin-top: 30px;
            border-left: 5px solid #8f0000;
            padding-left: 10px;
        }
        h3 {
            color: #c62828;
            margin-top: 20px;
        }
        .code-block {
            background-color: #f4f4f4;
            border: 1px solid #ddd;
            border-left: 4px solid #8f0000;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
        }
        .note {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        .important {
            background-color: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        .tip {
            background-color: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        .exercise {
            background-color: #e7f3ff;
            border: 2px solid #2196F3;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        .exercise h3 {
            color: #1976D2;
            margin-top: 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #8f0000;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .flow-diagram {
            background-color: #f8f9fa;
            border: 2px solid #dee2e6;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            text-align: center;
        }
        ul, ol {
            margin: 10px 0;
            padding-left: 30px;
        }
        li {
            margin: 5px 0;
        }
        details {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
        }
        summary {
            cursor: pointer;
            font-weight: bold;
            color: #8f0000;
            padding: 5px;
        }
        summary:hover {
            background-color: #e9ecef;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔀 Node-RED Split/Joinノード完全ガイド</h1>
        
        <div class="note">
            <strong>📘 このガイドについて</strong><br>
            このガイドでは、Node-REDのSplitノードとJoinノードの使い方を、基礎から応用まで段階的に学習します。
            配列やオブジェクトの分割・結合処理をマスターしましょう！
        </div>

        <h2>📚 目次</h2>
        <ol>
            <li><a href="#overview">Split/Joinノードとは</a></li>
            <li><a href="#basic-concepts">基本概念</a></li>
            <li><a href="#split-node">Splitノードの詳細</a></li>
            <li><a href="#join-node">Joinノードの詳細</a></li>
            <li><a href="#exercises">実践演習</a></li>
            <li><a href="#advanced">応用パターン</a></li>
        </ol>

        <h2 id="overview">1️⃣ Split/Joinノードとは</h2>
        
        <h3>概要</h3>
        <p>Split/Joinノードは、配列やオブジェクトを分割・結合するための強力なツールです。</p>
        
        <table>
            <tr>
                <th>ノード</th>
                <th>主な機能</th>
                <th>使用場面</th>
            </tr>
            <tr>
                <td><strong>Split</strong></td>
                <td>配列/オブジェクト/文字列を個別のメッセージに分割</td>
                <td>データを1つずつ処理したい時</td>
            </tr>
            <tr>
                <td><strong>Join</strong></td>
                <td>複数のメッセージを1つの配列/オブジェクトに結合</td>
                <td>分割したデータを再び集約したい時</td>
            </tr>
        </table>

        <h3>基本的な処理フロー</h3>
        <div class="flow-diagram">
            <p><strong>典型的な使用パターン</strong></p>
            <code>
                [配列データ] → [Split] → [処理] → [Join] → [結合された結果]
            </code>
        </div>

        <h2 id="basic-concepts">2️⃣ 基本概念</h2>

        <h3>なぜ分割・結合が必要なのか？</h3>
        
        <div class="tip">
            <strong>💡 実用例</strong><br>
            <ul>
                <li><strong>データ加工：</strong>配列内の各要素に対して個別に処理を適用</li>
                <li><strong>API呼び出し：</strong>複数のIDに対して順次APIをコール</li>
                <li><strong>フィルタリング：</strong>条件に合うデータのみを集約</li>
                <li><strong>並列処理：</strong>データを分割して並列に処理後、結果を統合</li>
            </ul>
        </div>

        <h3>メッセージのプロパティ</h3>
        <p>Splitノードは、分割されたメッセージに以下の特別なプロパティを追加します：</p>
        
        <table>
            <tr>
                <th>プロパティ</th>
                <th>説明</th>
                <th>例</th>
            </tr>
            <tr>
                <td><code>msg.parts.index</code></td>
                <td>現在のメッセージのインデックス（0始まり）</td>
                <td>0, 1, 2, ...</td>
            </tr>
            <tr>
                <td><code>msg.parts.count</code></td>
                <td>全体のメッセージ数</td>
                <td>5</td>
            </tr>
            <tr>
                <td><code>msg.parts.id</code></td>
                <td>メッセージグループの一意なID</td>
                <td>"a1b2c3d4"</td>
            </tr>
            <tr>
                <td><code>msg.parts.type</code></td>
                <td>元のデータ型</td>
                <td>"array", "object", "string"</td>
            </tr>
        </table>

        <div class="important">
            <strong>⚠️ 重要：</strong><code>msg.parts</code>プロパティは、JoinノードがSplitで分割されたメッセージを正しく結合するために使用されます。
            このプロパティを削除または変更すると、Joinノードが正常に動作しなくなる可能性があります。
        </div>

        <h2 id="split-node">3️⃣ Splitノードの詳細</h2>

        <h3>配列の分割</h3>
        <p>最も一般的な使用方法です。</p>
        
        <div class="code-block">// 入力例
msg.payload = [10, 20, 30, 40, 50];

// Splitノード通過後、5つのメッセージに分割される：
// メッセージ1: msg.payload = 10, msg.parts.index = 0
// メッセージ2: msg.payload = 20, msg.parts.index = 1
// メッセージ3: msg.payload = 30, msg.parts.index = 2
// メッセージ4: msg.payload = 40, msg.parts.index = 3
// メッセージ5: msg.payload = 50, msg.parts.index = 4</div>

        <h3>オブジェクトの分割</h3>
        <p>オブジェクトを分割すると、キーと値のペアがそれぞれメッセージになります。</p>
        
        <div class="code-block">// 入力例
msg.payload = {
    "apple": 100,
    "banana": 80,
    "orange": 120
};

// Splitノード通過後、3つのメッセージに分割される：
// メッセージ1: msg.payload = 100, msg.topic = "apple"
// メッセージ2: msg.payload = 80, msg.topic = "banana"
// メッセージ3: msg.payload = 120, msg.topic = "orange"</div>

        <div class="note">
            <strong>📝 注意：</strong>オブジェクトを分割すると、キー名は<code>msg.topic</code>に、値は<code>msg.payload</code>に格納されます。
        </div>

        <h3>文字列の分割</h3>
        <p>文字列を指定された区切り文字で分割できます。</p>
        
        <div class="code-block">// 入力例
msg.payload = "赤,青,黄,緑";

// Splitノード設定：区切り文字を ","（カンマ）に設定
// 分割後：
// メッセージ1: msg.payload = "赤"
// メッセージ2: msg.payload = "青"
// メッセージ3: msg.payload = "黄"
// メッセージ4: msg.payload = "緑"</div>

        <h3>Splitノードの設定オプション</h3>
        <table>
            <tr>
                <th>設定項目</th>
                <th>説明</th>
            </tr>
            <tr>
                <td>msg.payload</td>
                <td>分割するメッセージプロパティ（デフォルト）</td>
            </tr>
            <tr>
                <td>Fixed Length</td>
                <td>配列を指定した長さのチャンクに分割</td>
            </tr>
            <tr>
                <td>Copy key to</td>
                <td>オブジェクトのキーをコピーするプロパティ名</td>
            </tr>
        </table>

        <h2 id="join-node">4️⃣ Joinノードの詳細</h2>

        <h3>自動モード（Automatic）</h3>
        <p>最もシンプルなモード。Splitノードで分割されたメッセージを自動的に元の形式に結合します。</p>
        
        <div class="code-block">// Splitで分割されたメッセージ（配列の場合）
// メッセージ1: msg.payload = 10
// メッセージ2: msg.payload = 20
// メッセージ3: msg.payload = 30

// Joinノード（自動モード）通過後
msg.payload = [10, 20, 30];</div>

        <div class="tip">
            <strong>💡 ヒント：</strong>自動モードは<code>msg.parts</code>プロパティを使用して、
            いつすべてのメッセージが揃ったかを判断します。
        </div>

        <h3>手動モード（Manual）</h3>
        <p>結合のタイミングや条件を手動で制御できます。</p>

        <h4>主な設定オプション：</h4>
        <ul>
            <li><strong>配列に結合：</strong>メッセージを配列として結合</li>
            <li><strong>文字列に結合：</strong>指定した区切り文字で文字列として結合</li>
            <li><strong>オブジェクトに結合：</strong>キー値ペアのオブジェクトとして結合</li>
        </ul>

        <h4>トリガー条件：</h4>
        <table>
            <tr>
                <th>条件</th>
                <th>説明</th>
                <th>使用例</th>
            </tr>
            <tr>
                <td>メッセージ数</td>
                <td>指定した数のメッセージを受信後に結合</td>
                <td>3つのメッセージごとに結合</td>
            </tr>
            <tr>
                <td>タイムアウト</td>
                <td>指定した時間内に受信したメッセージを結合</td>
                <td>5秒間のメッセージをまとめる</td>
            </tr>
            <tr>
                <td>特定メッセージ</td>
                <td>特定のプロパティを持つメッセージで結合をトリガー</td>
                <td>msg.complete = trueで結合</td>
            </tr>
        </table>

        <h3>結合モードの例</h3>
        
        <h4>文字列として結合：</h4>
        <div class="code-block">// 入力メッセージ
// メッセージ1: msg.payload = "Hello"
// メッセージ2: msg.payload = "World"
// メッセージ3: msg.payload = "Node-RED"

// Joinノード設定：文字列として結合、区切り文字 " "（スペース）
// 出力
msg.payload = "Hello World Node-RED";</div>

        <h4>オブジェクトとして結合：</h4>
        <div class="code-block">// 入力メッセージ
// メッセージ1: msg.payload = 25, msg.topic = "temperature"
// メッセージ2: msg.payload = 60, msg.topic = "humidity"

// Joinノード設定：オブジェクトとして結合、キーは msg.topic
// 出力
msg.payload = {
    "temperature": 25,
    "humidity": 60
};</div>

        <h2 id="exercises">5️⃣ 実践演習</h2>

        <div class="exercise">
            <h3>演習1: 配列要素の2倍化</h3>
            <p><strong>目標：</strong>配列の各要素を2倍にして新しい配列を作成する</p>
            
            <p><strong>手順：</strong></p>
            <ol>
                <li>Injectノードで配列 <code>[1, 2, 3, 4, 5]</code> を作成</li>
                <li>Splitノードで配列を分割</li>
                <li>Functionノードで各値を2倍にする（<code>msg.payload = msg.payload * 2;</code>）</li>
                <li>Joinノードで配列に結合（自動モード）</li>
                <li>Debugノードで結果を確認</li>
            </ol>

            <p><strong>期待される出力：</strong></p>
            <div class="code-block">[2, 4, 6, 8, 10]</div>

            <details>
                <summary>💡 ヒント</summary>
                <p>Splitノードの設定はデフォルトのままでOKです。Joinノードも「自動モード」を選択すれば、
                    自動的に元の配列形式に戻してくれます。</p>
            </details>

            <details>
                <summary>✅ 解答例</summary>
                <div class="code-block">// Injectノード
msg.payload = [1, 2, 3, 4, 5];
return msg;

// Functionノード（2倍にする）
msg.payload = msg.payload * 2;
return msg;</div>
            </details>
        </div>

        <div class="exercise">
            <h3>演習2: 条件に合うデータのフィルタリング</h3>
            <p><strong>目標：</strong>配列から50以上の値だけを抽出する</p>
            
            <p><strong>手順：</strong></p>
            <ol>
                <li>Injectノードで配列 <code>[23, 67, 45, 89, 12, 56]</code> を作成</li>
                <li>Splitノードで配列を分割</li>
                <li>Switchノードで50以上の値だけを通過させる</li>
                <li>Joinノードで配列に結合</li>
                <li>Debugノードで結果を確認</li>
            </ol>

            <p><strong>期待される出力：</strong></p>
            <div class="code-block">[67, 89, 56]</div>

            <details>
                <summary>💡 ヒント</summary>
                <p>Switchノードの条件設定：</p>
                <ul>
                    <li>プロパティ: <code>msg.payload</code></li>
                    <li>条件: <code>&gt;=</code>（以上）</li>
                    <li>値: <code>50</code></li>
                </ul>
                <p>Joinノードは「手動モード」で、「タイムアウト後に結合」を設定するか、
                    Splitから来た<code>msg.parts</code>情報を利用して自動結合することもできます。</p>
            </details>

            <details>
                <summary>✅ 解答例</summary>
                <div class="code-block">// Injectノード
msg.payload = [23, 67, 45, 89, 12, 56];
return msg;

// Switchノード設定
// ルール1: msg.payload >= 50</div>
                <p><strong>注意：</strong>Switchノードでフィルタリングすると、<code>msg.parts.count</code>が変わらないため、
                    Joinノードの自動モードが正しく動作しない場合があります。その場合は、Changeノードで
                    <code>msg.parts.count</code>を調整するか、Joinノードのタイムアウト機能を使用してください。</p>
            </details>
        </div>

        <div class="exercise">
            <h3>演習3: オブジェクトの分割と集計</h3>
            <p><strong>目標：</strong>商品の価格オブジェクトから、各商品の情報を文字列で表示</p>
            
            <p><strong>手順：</strong></p>
            <ol>
                <li>Injectノードでオブジェクト <code>{"りんご": 100, "バナナ": 80, "オレンジ": 120}</code> を作成</li>
                <li>Splitノードでオブジェクトを分割</li>
                <li>Functionノードで「商品名: 価格円」の形式に整形</li>
                <li>Joinノードで文字列として結合（改行で区切る）</li>
                <li>Debugノードで結果を確認</li>
            </ol>

            <p><strong>期待される出力：</strong></p>
            <div class="code-block">りんご: 100円
バナナ: 80円
オレンジ: 120円</div>

            <details>
                <summary>💡 ヒント</summary>
                <p>Splitノードでオブジェクトを分割すると：</p>
                <ul>
                    <li><code>msg.topic</code>にキー名（商品名）が入る</li>
                    <li><code>msg.payload</code>に値（価格）が入る</li>
                    <li>これらを組み合わせて文字列を作成</li>
                </ul>
                <p><strong>Functionノードのコード例:</strong></p>
                <div class="code-block">// 商品名と価格を整形
msg.payload = msg.topic + ": " + msg.payload + "円";
return msg;</div>
                <p>Joinノードは「手動モード」で「文字列として結合」を選択し、区切り文字を <code>\n</code>（改行）に設定します。</p>
            </details>

            <details>
                <summary>✅ 解答例</summary>
                <div class="code-block">// Injectノード
msg.payload = {
    "りんご": 100,
    "バナナ": 80,
    "オレンジ": 120
};
return msg;

// Functionノード
msg.payload = msg.topic + ": " + msg.payload + "円";
return msg;

// Joinノード設定
// モード: 手動
// 結合形式: 文字列
// 区切り文字: \n</div>
            </details>
        </div>

        <div class="exercise">
            <h3>演習4: バッチ処理（固定長分割）</h3>
            <p><strong>目標：</strong>10個のデータを3個ずつのグループに分けて処理</p>
            
            <p><strong>手順：</strong></p>
            <ol>
                <li>Injectノードで配列 <code>[1,2,3,4,5,6,7,8,9,10]</code> を作成</li>
                <li>Splitノードで「Fixed Length」を3に設定</li>
                <li>Debugノードで各バッチを確認</li>
                <li>（オプション）Joinノードで元に戻す</li>
            </ol>

            <p><strong>期待される出力（Splitノード直後）：</strong></p>
            <div class="code-block">// メッセージ1
msg.payload = [1, 2, 3]

// メッセージ2
msg.payload = [4, 5, 6]

// メッセージ3
msg.payload = [7, 8, 9]

// メッセージ4
msg.payload = [10]</div>

            <details>
                <summary>💡 ヒント</summary>
                <p>Splitノードの設定で「arrayLength」または「Fixed Length」オプションを探してください。
                    これにより、配列を指定したサイズのチャンクに分割できます。</p>
            </details>
        </div>

        <h2 id="advanced">6️⃣ 応用パターン</h2>

        <h3>パターン1: 並列API呼び出しの制御</h3>
        <p>複数のIDに対してAPIを呼び出し、すべての結果を集約する例：</p>
        
        <div class="flow-diagram">
            <code>
                [ID配列] → [Split] → [Delay(レート制限)] → [HTTP Request] → [Join] → [結果配列]
            </code>
        </div>

        <div class="code-block">// 入力
msg.payload = [101, 102, 103, 104, 105];

// Splitで分割 → 各IDでAPI呼び出し → Joinで結果を集約
// 最終出力は各APIレスポンスの配列</div>

        <div class="tip">
            <strong>💡 実用的なヒント：</strong>
            <ul>
                <li>Delayノードで「Rate Limit」を設定し、API呼び出しの頻度を制限</li>
                <li>HTTP Requestノードのタイムアウトを適切に設定</li>
                <li>Joinノードのタイムアウトを設定し、一部のAPIが失敗しても処理を完了</li>
            </ul>
        </div>

        <h3>パターン2: データ変換パイプライン</h3>
        <p>複数の変換処理を順次適用する例：</p>
        
        <div class="flow-diagram">
            <code>
                [配列] → [Split] → [変換1] → [変換2] → [フィルタ] → [Join] → [結果]
            </code>
        </div>

        <div class="code-block">// 例：ユーザーデータの加工
// 入力
[
    {name: "田中", age: 25},
    {name: "佐藤", age: 17},
    {name: "鈴木", age: 30}
]

// 処理フロー
// 1. Split で分割
// 2. Function で敬称追加（name + "さん"）
// 3. Switch で20歳以上をフィルタ
// 4. Join で結合

// 出力
[
    {name: "田中さん", age: 25},
    {name: "鈴木さん", age: 30}
]</div>

        <h3>パターン3: リアルタイムストリーム処理</h3>
        <p>センサーデータを時間窓でグループ化して統計処理：</p>
        
        <div class="flow-diagram">
            <code>
                [センサー] → [Join(5秒タイムアウト)] → [Function(平均計算)] → [Dashboard]
            </code>
        </div>

        <div class="code-block">// Joinノード設定
// モード: 手動
// 結合: 配列に
// タイムアウト: 5秒ごとに送信

// Functionノード（平均値計算）
let sum = 0;
for (let i = 0; i < msg.payload.length; i++) {
    sum += msg.payload[i];
}
msg.payload = sum / msg.payload.length;
return msg;</div>

        <h3>パターン4: エラーハンドリング付き処理</h3>
        <p>分割処理中のエラーを適切に処理する例：</p>
        
        <div class="flow-diagram">
            <code>
                [配列] → [Split] → [Try-Catch処理] → [成功/失敗で分岐] → [Join] → [結果とエラーレポート]
            </code>
        </div>

        <div class="code-block">// Functionノード（Try-Catch付き処理）
try {
    // 何らかの処理
    msg.payload = someProcessing(msg.payload);
    msg.success = true;
} catch(e) {
    msg.payload = {
        error: e.message,
        original: msg.payload
    };
    msg.success = false;
}
return msg;

// Switchノードで成功/失敗を振り分け
// 成功したものだけをJoinで結合するなど</div>

        <h2>🎯 まとめ</h2>

        <div class="tip">
            <strong>🌟 Split/Joinノード活用のベストプラクティス：</strong>
            <ol>
                <li><strong>シンプルに始める：</strong>まずは基本的な配列の分割・結合から</li>
                <li><strong>msg.partsを理解する：</strong>このプロパティが分割・結合の鍵</li>
                <li><strong>適切なモードを選択：</strong>自動モード vs 手動モード</li>
                <li><strong>エラーハンドリング：</strong>タイムアウトや例外処理を考慮</li>
                <li><strong>パフォーマンス：</strong>大量データの場合はレート制限を検討</li>
                <li><strong>デバッグ：</strong>各ステップにDebugノードを配置して動作確認</li>
            </ol>
        </div>

        <div class="important">
            <strong>⚠️ よくある落とし穴：</strong>
            <ul>
                <li><code>msg.parts</code>を誤って削除または変更してしまう</li>
                <li>Joinノードのタイムアウトが短すぎて、すべてのメッセージが到着する前に結合してしまう</li>
                <li>Switchノードでフィルタリング後、<code>msg.parts.count</code>が実際のメッセージ数と合わない</li>
                <li>非同期処理（HTTP Requestなど）で順序が変わってしまう</li>
            </ul>
        </div>

        <h2>📚 さらなる学習リソース</h2>
        <ul>
            <li><a href="https://nodered.org/docs/user-guide/messages#message-sequences" target="_blank">Node-RED公式ドキュメント: Message Sequences</a></li>
            <li><a href="https://flows.nodered.org/" target="_blank">Node-REDフローライブラリ</a> - 実例を検索</li>
            <li>コミュニティフォーラムでの質問と回答</li>
        </ul>

        <div class="note">
            <strong>📝 このガイドの活用方法：</strong><br>
            各演習を実際にNode-REDで試してみることをお勧めします。手を動かすことで、
            Split/Joinノードの動作を深く理解できます。わからないことがあれば、ヒントや解答例を参考にしてください。
        </div>

        <hr>
        <p style="text-align: center; color: #666; margin-top: 30px;">
            <small>© 2024 Node-RED Split/Join完全ガイド | 学習用教材</small>
        </p>
    </div>
</body>
</html>